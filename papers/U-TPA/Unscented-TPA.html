<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Joshua Meggitt">
<meta name="author" content="Bart Forrier">
<meta name="author" content="Fabio Bianciardi">
<meta name="dcterms.date" content="2025-01-01">

<title>Unscented-TPA: a general uncertainty framework for Transfer Path Analysis – Joshua Meggitt</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../papers/papers.html" rel="prev">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-045f01e90fa491bba6c51fbe92305c42.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Joshua Meggitt</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../introductions/introductions.html"> 
<span class="menu-text">A quick introduction to:</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../papers/papers.html" aria-current="page"> 
<span class="menu-text">Papers</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../tutorials/tutorials.html"> 
<span class="menu-text">Tutorials</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../book.html"> 
<span class="menu-text">Book</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-teaching" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Teaching</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-teaching">    
        <li>
    <a class="dropdown-item" href="../../mlsd.html">
 <span class="dropdown-text">Microphone and Loudspeaker Design</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../poav.html">
 <span class="dropdown-text">Principles of Acoustics and Vibration</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../papers/U-TPA/Unscented-TPA.html">Unscented-TPA</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../papers/papers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">List of papers</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../papers/U-TPA/Unscented-TPA.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Unscented-TPA</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-Theory" id="toc-sec-Theory" class="nav-link" data-scroll-target="#sec-Theory"><span class="header-section-number">2</span> Theory</a>
  <ul class="collapse">
  <li><a href="#the-inverse-identification-of-forces" id="toc-the-inverse-identification-of-forces" class="nav-link" data-scroll-target="#the-inverse-identification-of-forces"><span class="header-section-number">2.1</span> The inverse identification of forces</a></li>
  <li><a href="#prediction-of-operational-responses-using-acquired-force" id="toc-prediction-of-operational-responses-using-acquired-force" class="nav-link" data-scroll-target="#prediction-of-operational-responses-using-acquired-force"><span class="header-section-number">2.2</span> Prediction of operational responses using acquired force</a></li>
  <li><a href="#sec-dual" id="toc-sec-dual" class="nav-link" data-scroll-target="#sec-dual"><span class="header-section-number">2.3</span> Esitmation of forward FRF by sub-structuring</a></li>
  </ul></li>
  <li><a href="#sec-Uncert" id="toc-sec-Uncert" class="nav-link" data-scroll-target="#sec-Uncert"><span class="header-section-number">3</span> Analysis of uncertainty</a>
  <ul class="collapse">
  <li><a href="#sec-MC" id="toc-sec-MC" class="nav-link" data-scroll-target="#sec-MC"><span class="header-section-number">3.1</span> Monte-Carlo</a></li>
  <li><a href="#linearisation-lpu" id="toc-linearisation-lpu" class="nav-link" data-scroll-target="#linearisation-lpu"><span class="header-section-number">3.2</span> Linearisation (LPU)</a>
  <ul class="collapse">
  <li><a href="#inverse-force-identification" id="toc-inverse-force-identification" class="nav-link" data-scroll-target="#inverse-force-identification"><span class="header-section-number">3.2.1</span> Inverse force identification</a></li>
  <li><a href="#response-prediction" id="toc-response-prediction" class="nav-link" data-scroll-target="#response-prediction"><span class="header-section-number">3.2.2</span> Response prediction</a></li>
  <li><a href="#sub-structuring" id="toc-sub-structuring" class="nav-link" data-scroll-target="#sub-structuring"><span class="header-section-number">3.2.3</span> Sub-structuring</a></li>
  </ul></li>
  <li><a href="#unscented-transformation" id="toc-unscented-transformation" class="nav-link" data-scroll-target="#unscented-transformation"><span class="header-section-number">3.3</span> Unscented transformation </a></li>
  </ul></li>
  <li><a href="#sec-numSim" id="toc-sec-numSim" class="nav-link" data-scroll-target="#sec-numSim"><span class="header-section-number">4</span> Numerical examples</a>
  <ul class="collapse">
  <li><a href="#sub-structuring---uncertain-joint-dynamics" id="toc-sub-structuring---uncertain-joint-dynamics" class="nav-link" data-scroll-target="#sub-structuring---uncertain-joint-dynamics"><span class="header-section-number">4.1</span> Sub-structuring - uncertain joint dynamics</a></li>
  <li><a href="#force-identification" id="toc-force-identification" class="nav-link" data-scroll-target="#force-identification"><span class="header-section-number">4.2</span> Force identification</a></li>
  </ul></li>
  <li><a href="#sec-expEx" id="toc-sec-expEx" class="nav-link" data-scroll-target="#sec-expEx"><span class="header-section-number">5</span> Experimental example</a></li>
  <li><a href="#sec-conc" id="toc-sec-conc" class="nav-link" data-scroll-target="#sec-conc"><span class="header-section-number">6</span> Conclusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unscented-TPA: a general uncertainty framework for Transfer Path Analysis</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Authors</div>
  <div class="quarto-title-meta-heading">Affiliations</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Joshua Meggitt <a href="mailto:j.w.r.meggitt1@salford.ac.uk" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Acoustics Research Centre, University of Salford
          </p>
        <p class="affiliation">
            
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Bart Forrier </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Seimens Digital Industries Software
          </p>
        <p class="affiliation">
            
          </p>
      </div>
    <div class="quarto-title-meta-contents">
    <p class="author">Fabio Bianciardi </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            Seimens Digital Industries Software
          </p>
        <p class="affiliation">
            
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 1, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Transfer Path Analysis is a term used to describe a broad class of methods that evaluate the vibro-acoustic performance of complex built-up structures. Applications of TPA can be catagorised as diagnostic or predictive. Diagnostic applications consider an and aim to quantify the relative contributions of the various vibration sources present to the overall vibro-acoustic response. These contributions are often rank ordered to identify troublesome sources and so inform design modifications for improved performance. Predictive applications instead aim to simulate the overall response of a structure , i.e.&nbsp;they concern a virtual assembly. This is done by adopting a component-based approach, whereby individual components are first characterised, before being substructured together to build a model of the assembly. This model is then subject to external forces that describe, in an equivalent way, the internal (operational) mechanisms of vibration sources present. This approach is often termed Component-based TPA, or Vibro-Acoustic Virtual Prototyping (VAVP) .</p>
<p>In either application, a TPA exercise will inevitably involve some experimental testing, either on the assembly (diagnostic) or at a component level (predictive). Consequently, any results obtained will be subject to experimental error/uncertainty. If these results are to inform design changes or set targets, it is important that some quantitative measure of their reliability is available. After all, a prediction is only meaningful when it’s accompanied by a measure of its uncertainty . To this end, we are interested in the analysis of uncertainty within the general framework of TPA.</p>
<p>To deal with the above, we introduce (U-TPA), a general framework for uncertainty estimation within TPA. U-TPA is based on the so-called Unscented Transform (UT) , which has seen tremendous success in the field of state-estimation , where it is used to propagate uncertainty (mean and covariance) through arbitrary non-linear dynamical functions. In contrast to existing methods, U-TPA provides second-order accuracy (at the computational cost of first-order methods) and can be applied immediately to any form of TPA, including formulations with complex regularisation schemes for which first order methods are not available.</p>
<p>Whilst TPA as a general methodology has been around for over three decades, only in recent years have efforts been devoted to the treatment of its uncertainty. The most complete treatment is found in where Meggitt et al.&nbsp;present a linearised (first-order) framework for the propagation of uncertainty through inverse force identification , substructuring (primal and dual) and forward response prediction. The framework was shown to give good agreement with Monte-Carlo methods for low-to-mid levels input uncertainty, with deviations occurring at higher levels (expected given first-order accuracy). The importance of capturing any correlations between measurements (notably FRFs that share the same excitation ) was stressed and shown to be crucial for obtaining an accurate estimate of uncertainty.The above framework was derived from the standard form of the TPA equations, including over-determined solutions but with no regularisation on either the force identification or substructuring steps. This is somewhat limiting, as regularisation is often employed to better condition inverse problems like those described above. To overcome this limitation would mean having to re-derive the multi-dimensional Jacobian matrices that describe the linearised set of equations, including the regularisation scheme of interest. To the authors knowledge no such derivations are available in the literature. In contrast, the proposed U-TPA is a derivative-free method, meaning it can be applied immediately to any form of the TPA equations (including regularised solutions).</p>
<p>In addition to the above works, several authors have presented more targeted treatments of uncertainty. The earliest account relevant to TPA is that by Voormeren et al.&nbsp; who proposed a first-order uncertainty propagation for the dual substructuring formulation. Unlike later developments, it was assumed in this work that the underlying uncertainty was uncorrelated, thus yielding a simplified set of equations of limited practical application. This work was further developed in , where authors introduced possible correlations between variables. A notable difference between the treatments found in and is in how the uncertainty of variables is handled. In , a complex quantity and its conjugate are treated as independent variables . In , the real and imaginary parts of each complex quantity are treated as separate (though possibly correlated) variables. Though this latter representation is arguably more intuitive, both approaches effectively provide the same uncertainty propagation.</p>
<p>The above treatments of uncertainty are all based on a linearisation of the TPA equations, as described by the Law of Propagation of Uncertainty (LPU) . Whilst this approach is recommended by the ISO supported document (GUM) , it is inherently limited to small levels of uncertainty and weakly non-linear functions. However, many of the TPA equations are in-fact non-linear (with respect to the uncertain parameters), and so these first-order methods breakdown for mid-high levels of uncertainty. In authors present a second-order extension of the framework presented in by introducing the Hessian (matrix of second-order derivatives) alongside the previously established Jacobians. Results show improved accuracy at higher levels of uncertainty, albeit it at the cost of complexity and computational effort. Though extended to second-order accuracy, this work remains limited to the standard form of the underlying equation, i.e.&nbsp;in the absence of any regularisation.</p>
<p>In contrast to the above methods, which attempt to approximate the underlying TPA equations (to first or second-order), the proposed U-TPA involves the direct evaluation of the underlying functions, and hence implicitly captures their non-linearity. The functions are not however, evaluated for a set of randomly sampled inputs, as is done for the computationally expensive Monte-Carlo simulation, rather, the functions are evaluated for a reduced set of chosen , which together provide an approximation of the input’s multi-dimensional distribution. Remarkably, it has been shown that this simple sampling-based approach guarantees at least second-order accuracy, and does so with computational effort similar to typical first order methods . Based on direct function evaluations, U-TPA can be applied directly to any formulation of the TPA equations, including arbitrary regularisation schemes or complex interface transformations. It is shown through a series of examples that U-TPA out performs first-order (LPU) methods in all cases yielding good agreement with Monte-Carlo simulations, and is able to accurately estimate the uncertainty of complex regularised inverse problems.</p>
<p>Having now introduced the context of this paper, its remainder will be structured as follows. In <a href="#sec-Theory" class="quarto-xref">Section&nbsp;2</a> we briefly recap the theory of TPA by introducing the three key equations. Section <a href="#sec-Uncert" class="quarto-xref">Section&nbsp;3</a> is then devoted to the analysis of uncertainty in TPA, describing the Monte-Carlo (MC), Linearised Propagation of Uncertainty (LPU) and Unscented-TPA (U-TPA) methods. In Section <span class="math inline">\(\ref{sec:NumSim}\)</span> we consider two numerical toy problems and compare the above methods; the first problem considers the influence of uncertain joint dynamics, and the second a typical inverse force identification. Section <span class="math inline">\(\ref{sec:Exp}\)</span> then presents an experimental case study involving the inverse identification of forces, and their on-board validation. Finally, in Section <span class="math inline">\(\ref{sec:Conc}\)</span> we draw some concluding remarks.</p>
</section>
<section id="sec-Theory" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Theory</h1>
<p>In this section we introduce the main theory relevant to this paper. We begin with a brief summary of the key TPA equations, followed by a description of the Monte-Carlo (MC), Linearisation (LPU) and Unscented Transformation (UT) analyses of uncertainty in the context of the TPA equations.</p>
<p>The theory underlying TPA is described in great detail in numerous papers, see for example . It is assumed that the reader is familiar with this theory, and so our description will be kept brief.</p>
<p>Effectively, there are three equations that govern majority of TPA exercises. These are expressed in the frequency domain (with explicit <span class="math inline">\(\omega\)</span> notation omitted for clarity) and are described below.</p>
<section id="the-inverse-identification-of-forces" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="the-inverse-identification-of-forces"><span class="header-section-number">2.1</span> The inverse identification of forces</h2>
<p><span id="eq-invForce"><span class="math display">\[
    \mathbf{f} = \mathbf{Y}^+\mathbf{v}
\tag{1}\]</span></span> Here, <span class="math inline">\(\mathbf{Y}\in\mathbb{C}^{N_r\times N_f}\)</span> is a complex <span class="math inline">\(N_r\times N_f\)</span> matrix of Frequency Response Functions (FRFs) that relate the measured operational responses <span class="math inline">\(\mathbf{v}\in\mathbb{C}^{N_r}\)</span> to the sought after forces <span class="math inline">\(\mathbf{f}\in\mathbb{C}^{N_f}\)</span> and <span class="math inline">\(\square^+\)</span> denotes a generalized matrix (pseudo-)inverse. If the FRFs are measured whilst the source and receiver components are assembled (denoted <span class="math inline">\(\mathbf{Y}_C\)</span>), the acquired forces are termed (also equivalent forces). If the FRFs are measured on the receiver whilst the source is detached (denoted <span class="math inline">\(\mathbf{Y}_R\)</span>), the acquired forces are termed . Blocked forces have the advantage that they are transferable between assemblies, thus enabling virtual prototyping and component-based simulation.</p>
<p>It should be noted that the measured FRF matrix <span class="math inline">\(\mathbf{Y}\)</span> is typically subject to some interface transformation, for example the Virtual Point , so to obtain co-located translational and rotational DoFs. This transformation should be accounted for in any uncertainty analyses. For LPU, this requires obtaining a Jacobian said transformation. For UT and MC methods, which are based on function evaluations, no extra effort is required.</p>
</section>
<section id="prediction-of-operational-responses-using-acquired-force" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="prediction-of-operational-responses-using-acquired-force"><span class="header-section-number">2.2</span> Prediction of operational responses using acquired force</h2>
<p><span id="eq-forwardPred"><span class="math display">\[
    \mathbf{p} = \mathbf{H}\mathbf{f}
\tag{2}\]</span></span> Here, <span class="math inline">\(\mathbf{H}\in\mathbb{C}^{N_p\times N_f}\)</span> is a matrix of (forward) FRFs that relate the acquired force <span class="math inline">\(\mathbf{f}\in\mathbb{C}^{N_f}\)</span> to the target response variables <span class="math inline">\(\mathbf{p}\in\mathbb{C}^{N_p}\)</span>. We have used the notation <span class="math inline">\(\mathbf{p}\)</span> and <span class="math inline">\(\mathbf{H}\)</span> for generality and to avoid confusion with <span class="math inline">\(\mathbf{v}\)</span> and <span class="math inline">\(\mathbf{Y}\)</span> used in <a href="#eq-invForce" class="quarto-xref">Equation&nbsp;1</a>, though in general the response could be structural and/or acoustic. If a force has been acquired, the forward FRFs must be measured on the coupled assembly, i.e.&nbsp;with the source and receiver attached, <span class="math inline">\(\mathbf{H}_C\)</span>. This is commonly termed <em>in-situ</em> or <em>blocked force TPA</em>. If a <em>contact</em> force is measured, the forward FRF should be for the receiver alone, <span class="math inline">\(\mathbf{H}_R\)</span>. This is commonly termed <em>classical</em> or <em>matrix inverse TPA</em>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In a TPA exercise, interest is usually on the ranked contribution of individual forces to the response <span class="math inline">\(\mathbf{p}\)</span>. This diagnostic analysis enables the identification of troublesome contributions, and the design of appropriate modifications.</p>
</div>
</div>
</section>
<section id="sec-dual" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="sec-dual"><span class="header-section-number">2.3</span> Esitmation of forward FRF by sub-structuring</h2>
<p><span id="eq-dual"><span class="math display">\[
            \mathbf{H}_C = \mathbf{Y} - \mathbf{Y}\mathbf{B}^{\rm T}\left(\mathbf{B} \mathbf{Y} \mathbf{B}^{
            \rm T} + \mathbf{\Gamma}\right)^{-1} \mathbf{B}\mathbf{Y},
\tag{3}\]</span></span> Here, $ _C^{N_CN_C}$ is the FRF matrix of the coupled assembly, <span class="math inline">\(\mathbf{Y}\in\mathbb{C}^{(N_S+N_R)\times(N_S+N_R)}\)</span> is a block diagonal matrix containing the uncoupled FRF matrices of the source <span class="math inline">\(S\)</span> and receiver <span class="math inline">\(R\)</span> components, <span class="math inline">\(\mathbf{\Gamma}\in\mathbb{C}^{N_c\times N_c}\)</span> is a matrix of joint flexibilities that describes the dynamics of the connecting DoFs, and <span class="math inline">\(\mathbf{B}\in\mathbb{Z}^{N_c\times(N_S+N_R)}\)</span> is a signed Boolean matrix that controls between which DoFs equilibrium is enforced. <a href="#eq-dual" class="quarto-xref">Equation&nbsp;3</a> can be used to estimate the forward FRF for use in <a href="#eq-forwardPred" class="quarto-xref">Equation&nbsp;2</a> when used with the blocked force. This is commonly termed <em>Component-based TPA</em> (CTPA) or <em>Vibro-Acoustic Virtual Prototyping</em> (VAVP).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Whilst commonly referred to as TPA, the use of sub-structuring makes this more of a predictive, as opposed to diagnostic, methodology. Interest is typically in the total system response, for example to facilitate auralisation of the virtual prototype.</p>
</div>
</div>
</section>
</section>
<section id="sec-Uncert" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Analysis of uncertainty</h1>
<p>TPA is largely an experimental methodology, relying on the measurement of assembly/component FRF matrices and operational responses; the variables <span class="math inline">\(\mathbf{Y}\)</span>, <span class="math inline">\(\mathbf{H}\)</span> and <span class="math inline">\(\mathbf{v}\)</span> through <a href="#eq-invForce" class="quarto-xref">Equations&nbsp;1</a> - <a href="#eq-dual" class="quarto-xref">3</a> should be thought of as <em>random variables</em> as they are all subject to experimental uncertainty. This uncertainty can arise for a multitude of reasons, including: poor signal to noise ratio, inaccurate impact position/orientation when measuring FRFs, uncertain sensor position/orientation, etc. As stressed in the introduction, if the results of a TPA campaign are to guide product design, it is important that some quantitative measure of their reliability is available. To this end, we are interested in how this experimental uncertainty propagates through the TPA equations. To begin answering this question, it will be convenient to represent our TPA equations in a more general form,<br>
<span class="math display">\[\begin{equation}\label{genEq}
    \mathbf{y} = G(\mathbf{x})
\end{equation}\]</span> where <span class="math inline">\(\mathbf{x}\in\mathbb{R}^N\)</span> is an <span class="math inline">\(N\)</span> dimensional real vector of measured parameters, <span class="math inline">\(\mathbf{y}\in\mathbb{R}^M\)</span> is an <span class="math inline">\(M\)</span> dimensional vector of estimated parameters, and <span class="math inline">\(G(\square)\)</span> is our general function, here representing the inverse force identification, forward response prediction or sub-structuring calculations. To admit this form, the complex quantities that are our measured FRFs and operational responses must be separated into their real and imaginary components, which we treat as separate variables. This separation can be represented by the element-wise function <span class="math inline">\(M(\quad)\)</span>, <span class="math display">\[\begin{equation}
    M\left(\begin{array} {c}
        a+ib \\
        c+id \\
        e+if
        \end{array}\right) = \left(\begin{array} {c}
        a\\
        b \\
        c\\
        d\\
        e\\
        f
        \end{array}\right)
\end{equation}\]</span> Note that any matrix quantities (i.e.&nbsp;FRFs) must first be vectorised by vertically stacking their columns, <span class="math display">\[\begin{equation}
\mathbf{A} = \left[\begin{array}{ccc}
        a&amp; d &amp;g \\
        b &amp; e &amp; h\\
        c &amp; f &amp;i
        \end{array}\right] \qquad
        \mathbf{\vec{A}} =  \left(\begin{array}{ccc ccc ccc}
            a&amp; b &amp;c &amp;
            d &amp; e &amp; f &amp;
            g &amp; h &amp;i
        \end{array}\right)^{\rm T}
\end{equation}\]</span> before separating their real and imaginary parts.</p>
<p>Using the above, the input (<span class="math inline">\(\mathbf{x}\)</span>) and output (<span class="math inline">\(\mathbf{y}\)</span>) vectors for the TPA equations are as follows: The inverse identification of forces <span class="math display">\[\begin{align}\nonumber
    \mathbf{x} &amp;= \left(\begin{array}{c}
        M(\mathbf{\vec{Y}}) \\\hline
        M(\mathbf{{v}})
    \end{array}\right) \\ &amp;= \left(\begin{array}{c c c c c | c c c c c} \mbox{Re}(Y_{11}) &amp; \mbox{Im}(Y_{11}) &amp; \cdots  &amp; \mbox{Re}(Y_{N_rN_f}) &amp; \mbox{Im}(Y_{N_rN_f}) &amp;  \mbox{Re}(v_{1}) &amp; \mbox{Im}(v_{1} &amp;\cdots &amp; \mbox{Re}(v_{N_r}) &amp; \mbox{Im}(v_{N_r})
    \end{array}\right)^{\rm T}\\
    \mathbf{y} &amp;= M(\mathbf{f}) =  \left(\begin{array}{c c c c c} \mbox{Re}(f_{1}) &amp; \mbox{Im}(f_{1}) &amp; \cdots  &amp; \mbox{Re}(f_{N_f}) &amp; \mbox{Im}(f_{N_f})
    \end{array}\right)^{\rm T}
\end{align}\]</span> Prediction of operational response using acquried force <span class="math display">\[\begin{align}
    \mathbf{x} &amp;= \left(\begin{array}{c}
        M(\mathbf{\vec{H}}) \\\hline
        M(\mathbf{{f}})
    \end{array}\right) \\ &amp;= \left(\begin{array}{c c c c c | c c c c c} \mbox{Re}(H_{11}) &amp; \mbox{Im}(H_{11}) &amp; \cdots  &amp; \mbox{Re}(H_{N_pN_f}) &amp; \mbox{Im}(H_{N_pN_f}) &amp;  \mbox{Re}(f_{1}) &amp; \mbox{Im}(f_{1} &amp;\cdots &amp; \mbox{Re}(f_{N_f}) &amp; \mbox{Im}(f_{N_f})
    \end{array}\right)^{\rm T}\nonumber \\
    \mathbf{y} &amp;= M(\mathbf{p}) =  \left(\begin{array}{c c c c c} \mbox{Re}(p_{1}) &amp; \mbox{Im}(p_{1}) &amp; \cdots  &amp; \mbox{Re}(p_{N_p}) &amp; \mbox{Im}(p_{N_p})
    \end{array}\right)^{\rm T}
\end{align}\]</span> Esitmation of forward FRF by sub-structuring <span class="math display">\[\begin{align}
    \mathbf{x} &amp;= \left(\begin{array}{c}
        M(\mathbf{[\vec{Y}]}) \\\hline
        M(\mathbf{\vec{Z}}_j)
    \end{array}\right) \\ &amp;= \left(\begin{array}{c c c c c | c c c c c} \mbox{Re}(Y_{11}) &amp; \mbox{Im}(Y_{11}) &amp; \cdots  &amp; \mbox{Re}(Y_{MN}) &amp; \mbox{Im}(Y_{MN}) &amp;  \mbox{Re}(Z_{11}) &amp; \mbox{Im}(Z_{11}) &amp;\cdots &amp; \mbox{Re}(Z_{n_jn_j}) &amp; \mbox{Im}(Z_{n_jn_j})
    \end{array}\right)^{\rm T}\nonumber \\
    \mathbf{y} &amp;= M(\mathbf{\vec{H}}_C) =  \left(\begin{array}{c c c c c} \mbox{Re}(H_{11}) &amp; \mbox{Im}(H_{11}) &amp; \cdots  &amp; \mbox{Re}(H_{N_CN_C}) &amp; \mbox{Im}(H_{N_CN_C})
    \end{array}\right)^{\rm T}
\end{align}\]</span></p>
<p>Having established a common form for all our TPA equations, the task is now to establish a procedure to quantify the uncertainty in <span class="math inline">\(\mathbf{x}\)</span> and estimate its propagation onto the output <span class="math inline">\(\mathbf{y}\)</span>.</p>
<p>To simplify the problem, it is common to assume that the experimental uncertainty introduced through measurement follows a multi-dimensional Normal distribution, and so <span class="math inline">\(\mathbf{x}\)</span> can be described entirely by its mean vector <span class="math inline">\(\mu_\mathbf{x}\in\mathbb{R}^N\)</span> and covariance matrix <span class="math inline">\(\Sigma_\mathbf{x}\in\mathbb{R}^{N\times N}\)</span>.</p>
<p>In the following subsections we outline three methodologies to analyses the propagation of uncertainty through <span class="math inline">\(G(\square)\)</span>. The first two, Monte-Carlo and Linearisation (LPU), are already been established in the literature. The third, based on the Unscented Transform (UT), is the main contribution of this paper.</p>
<section id="sec-MC" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-MC"><span class="header-section-number">3.1</span> Monte-Carlo</h2>
<p>Using a Monte-Carlo approach, we estimate the probability density function (PDF) of the output <span class="math inline">\(\mathbf{y}\)</span> by randomly sampling the distribution of the input <span class="math inline">\(\mathbf{x}\)</span>. Failing an analytical solution for the PDF of the output, which is rarely available for problems of realistic complexity, the Monte-Carlo approach is the most robust approach for the propagation of uncertainty; it is frequently used to provide estimates for the evaluation of alternative methods. By evaluating the function <span class="math inline">\(G(\square)\)</span> directly, we implicitly capture the effects of non-linearity and their influence on the output distribution. The main limitation of a MC simulation is simply the computation effort required, which can be great for high dimensional problems or expensive models.</p>
<p>A typical Monte-Carlo procedure is as follows:</p>
<ol type="1">
<li>A random sample <span class="math inline">\(\mathbf{x}_i\)</span> is drawn from the input distribution, for example the multi-dimensional Normal with mean <span class="math inline">\(\mu_\mathbf{x}\)</span> and covariance <span class="math inline">\(\Sigma_{\mathbf{x}}\)</span>, <span class="math display">\[\begin{equation}
     \mathbf{x}_i\sim \mathcal{N}(\mu_\mathbf{x},\Sigma_\mathbf{x})
\end{equation}\]</span></li>
<li>The drawn sample is used to evaluate the function <span class="math inline">\(G(\square)\)</span>, resulting in the output sample <span class="math inline">\(\mathbf{y}_i\)</span>. <span class="math display">\[\begin{equation}
      \mathbf{y}_i = G(\mathbf{x}_i)
\end{equation}\]</span></li>
<li>Steps 1 and 2 are repeated until <span class="math inline">\(N_{MC}\)</span> output samples have been obtained. Collectively, these samples approximate the PDF of the output <span class="math inline">\(\mathbf{y}\)</span>. They can be used to infer any statistics of interest, for example the mean and covariance, <span class="math display">\[\begin{equation}
     \mu_\mathbf{y} = \frac{1}{N_{MC}}\sum_{i=1}^{N_{MC}} \mathbf{y}_i\qquad \qquad
     \Sigma_\mathbf{y} = \frac{1}{N_{MC}-1}\sum_{i=1}^{N_{MC}} (\mathbf{y}_i - \mu_\mathbf{y})(\mathbf{y}_i - \mu_\mathbf{y})^{\rm T}
\end{equation}\]</span></li>
</ol>
<p>To avoid uneessecary function evaluations, stopping criteria can be incorporated into the above by using a recursive calculation of, for example, the mean and covairance.</p>
<p>The above MC procedure will be used later as part of the numerical and experimental examples to provide a ground truth uncertainty propagation.</p>
</section>
<section id="linearisation-lpu" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="linearisation-lpu"><span class="header-section-number">3.2</span> Linearisation (LPU)</h2>
<p>Perhaps the most common form of uncertainty propagation is that described by the (LPU). The LPU is described in great detail in the ISO supported document ‘’ (GUM), developed by the Joint Committee for Guides in Metrology. Effectively, it is based on a first order approximation of the function through which uncertainty is being propagated, and involves the propagation of input covariance using the partial derivatives of the underlying function.</p>
<p>Whilst the LPU provides a computationally efficient and analyical propagation of uncertainty, based on a linearised approximation of the model, it is only expected to yield accurate results for low levels of input uncertainty, or when applied to weakly non-linear functions. Nevertheless, its use is widespread and the method has been applied successfully to both inverse force identification and sub-structuring problems. In what follows we provide breif summary of the LPU method, including its application to the TPA equations described above.</p>
<p>The non-linear function <span class="math inline">\(G(\mathbf{x}_0+\boldsymbol{\Delta})\)</span>, whose input is perturbed by vector <span class="math inline">\(\boldsymbol{\Delta}\)</span>, can be expressed as a Taylor series about <span class="math inline">\(\mathbf{x}_0\)</span> in the following form, <span class="math display">\[\begin{align}
    \mathbf{y} &amp;= G(\mathbf{x}_0 + \boldsymbol{\Delta})\\
    &amp;= G(\mathbf{x}_0) + \mathbf{D}_{\Delta } G + \frac{ \mathbf{D}^2_{\Delta } G}{2!}
+ \frac{ \mathbf{D}^3_{\Delta } G}{3!} + \frac{ \mathbf{D}^4_{\Delta } G}{4!} \cdots
\end{align}\]</span> where $^i_{} G $ denotes the total differential of <span class="math inline">\(G(\mathbf{x})\)</span> when perturbed around <span class="math inline">\(\mathbf{x}_0\)</span> by <span class="math inline">\(\boldsymbol{\Delta}\)</span>. The <span class="math inline">\(i\)</span>th term in the above Taylor series is given by, <span class="math display">\[\begin{equation}
     \frac{ \mathbf{D}^i_{\Delta} G}{i!} = \frac{1}{i!} \left(\sum_{j=1}^N {\Delta_j}  \frac{\partial }{\partial x_j} \right)^i G(\mathbf{x})\Bigg |_{\mathbf{x}=\mathbf{x}_0}
\end{equation}\]</span> with <span class="math inline">\(\Delta_j\)</span> denoting the <span class="math inline">\(j\)</span>th element of the perturbation vector <span class="math inline">\(\boldsymbol{\Delta}\)</span>.</p>
<p>Linearisation assumes that all second and higher order terms contribute negligibly towards the output, and so, <span class="math display">\[\begin{align}
    \mathbf{y} \approx G(\mathbf{x}_0) + \mathbf{D}_{\Delta } G
\end{align}\]</span> Taking outer products and expectations, the linearised mean and covariance of the output <span class="math inline">\(\mathbf{y}\)</span> take the form, <span class="math display">\[\begin{equation}
\mu_\mathbf{y} = G(\mu_\mathbf{x})\qquad \mbox{and}\qquad
    \Sigma_{\mathbf{y}} = \mathbf{J}\Sigma_{\mathbf{x}}\mathbf{J}^{\rm T}
\end{equation}\]</span> where <span class="math inline">\(\mathbf{J}= \frac{\partial G(\mathbf{x})}{\partial \mathbf{x}}\)</span> is termed the of <span class="math inline">\(G(\mathbf{x})\)</span> and is a matrix of partial derivatives of the elements of <span class="math inline">\(\mathbf{y}\)</span> with respect to the elements of <span class="math inline">\(\mathbf{x}\)</span>, <span class="math display">\[\begin{equation}
    \mathbf{J} = \left[\begin{array}{cccc}
        \frac{\partial y_1}{\partial x_1} &amp; \frac{\partial y_1}{\partial x_2} &amp; \cdots &amp; \frac{\partial y_1}{\partial x_{N}}  \\
        \frac{\partial y_2}{\partial x_1} &amp; \frac{\partial y_2}{\partial x_2} &amp; \cdots &amp; \frac{\partial y_2}{\partial x_{N}}  \\
        \vdots &amp; \vdots&amp; \ddots &amp; \vdots   \\
        \frac{\partial y_M}{\partial x_1} &amp; \frac{\partial y_M}{\partial x_2} &amp; \cdots &amp; \frac{\partial y_M}{\partial x_{N}}  \\
        \end{array}\right]
\end{equation}\]</span></p>
<p>It is worth noting that this approach to propagating covariance matrices forms the basis of the so-called Kalman Filter for non-linear systems. Though in common use, it is widely recognised as being of limited practical use due to its low first order accuracy. Furthermore, the need to analytically derive and implement the function Jacobian is often a complex and error prone process.</p>
<p>Whilst the Jacobian matrices for standard form TPA problems have been derived analytically , common variants that incorporate techniques such as regularisation or general interface transformations are not yet available. For this reason, the LPU remains quite limited in the wider context of TPA.</p>
<p>Below, we briefly summarise the LPU’s application to the key TPA equations. These will be used later as part of the numerical and experimental examples. Detailed derivations can be found in .</p>
<section id="inverse-force-identification" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="inverse-force-identification"><span class="header-section-number">3.2.1</span> Inverse force identification</h3>
<p>The input and output mean and covariance are given by, <span class="math display">\[\begin{equation}
    \mu_{\mathbf{x}} = \left(\begin{array}{c}
        M(\mu_{\mathbf{\vec{Y}}}) \\
        M(\mu_\mathbf{{v}})
    \end{array} \right)
    \qquad   \Sigma_\mathbf{x} = \left[\begin{array}{ll} \Sigma_\mathbf{Y} &amp;    \mathbf{0} \\
        \mathbf{0}&amp; \Sigma_\mathbf{v}
    \end{array}\right] \qquad \mbox{and}\qquad
    \mu_{\mathbf{y}} = M(\mu_\mathbf{{f}})
    \qquad   \Sigma_\mathbf{y} = \Sigma_\mathbf{f}
\end{equation}\]</span></p>
<p>The Jacobian of the underlying function (<a href="#eq-invForce" class="quarto-xref">Equation&nbsp;1</a>) is given by <span class="math display">\[\begin{align}
        \mathbf{J} &amp;=  \left[ \begin{array}{c c}
            \mathbf{J}_{\mathbf{Y}} &amp; \mathbf{J}_\mathbf{v}
        \end{array}\right]\\
        \mathbf{J}_{\mathbf{Y}} &amp;=\mathcal{M}\left(-(\mathbf{Y^+}\mathbf{v})^{\rm T}\otimes\mathbf{Y^+}, \left[\left(((\mathbf{I}-\mathbf{Y}\mathbf{Y^+})\mathbf{v})^{\rm T}\otimes\mathbf{Y^+}  \mathbf{Y}^{\rm +H}\right)+ \left((\mathbf{Y}^{\rm +H}  \mathbf{Y^{+}}\mathbf{v})^{\rm T}\otimes(\mathbf{I}-\mathbf{Y^+}\mathbf{Y}) \right)\right]\mathbf{K}\right) \\
        \mathbf{J}_{\mathbf{v}} &amp;= \mathcal{M} \left(\mathbf{Y}^+,\mathbf{0}\right)
    \end{align}\]</span> where <span class="math inline">\(\mathcal{M}(A,B)\)</span> is an element-wise function defined as, <span class="math display">\[\begin{equation}
        \mathcal{M}(A,B) = \left[\begin{array}{c c}
            \mathrm{Re}\left(A+B\right) &amp; \phantom{-}\mathrm{Im}\left(-A+B\right) \\
            \mathrm{Im}\left(A+B\right)  &amp; -\mathrm{Re}\left(-A+B\right)
        \end{array}\right].
    \end{equation}\]</span></p>
</section>
<section id="response-prediction" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="response-prediction"><span class="header-section-number">3.2.2</span> Response prediction</h3>
<p>The input and output mean and covariance are given by, <span class="math display">\[\begin{equation}
    \mu_{\mathbf{x}} =  \left(\begin{array}{c}
        M(\mu_{\mathbf{\vec{H}}}) \\
        M(\mu_\mathbf{{f}})
    \end{array} \right) \qquad \Sigma_\mathbf{x} = \left[\begin{array}{ll} \Sigma_\mathbf{H} &amp;  {\color{gray}\Sigma_\mathbf{Hf}}\\
        {\color{gray}\Sigma_\mathbf{fH}}&amp; \Sigma_\mathbf{f}
    \end{array}\right] \qquad \mbox{and}\qquad  \mu_\mathbf{y} =
    M\left(\mu_{\mathbf{p}}\right) \qquad \Sigma_{\mathbf{y}} = \Sigma_{{\mathbf{p}}}
\end{equation}\]</span> Note that the cross-covariance terms <span class="math inline">\(\Sigma_\mathbf{fH}=\Sigma_\mathbf{Hf}^{\rm T}\)</span> are grayed out as they are often zero. Specifically, when the inverse (<span class="math inline">\(\mathbf{Y}\)</span>) and forward (<span class="math inline">\(\mathbf{H}\)</span>) FRFs are measured as part of separate tests, they are uncorrelated, and so the force and forward FRF are also uncorrelated. This is not the case if <span class="math inline">\(\mathbf{Y}\)</span> and <span class="math inline">\(\mathbf{H}\)</span> are measured simultaneously .</p>
<p>The Jacobian of the underlying function (<a href="#eq-forwardPred" class="quarto-xref">Equation&nbsp;2</a>) is given by, <span class="math display">\[\begin{align}
    \mathbf{J} =   \left[ \begin{array}{c c}
        \mathbf{J}_{\mathbf{H}} &amp; \mathbf{J}_{\mathbf{f}}
    \end{array}\right] \qquad \qquad \mathbf{J_H} = \, \mathcal{M}\left(\mathbf{{f}^T}\otimes \mathbf{I}, \, \mathbf{0}\right) \qquad \qquad
    \mathbf{J_{f}} = \, \mathcal{M}\left(\mathbf{H}, \, \mathbf{0}\right)
\end{align}\]</span></p>
</section>
<section id="sub-structuring" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="sub-structuring"><span class="header-section-number">3.2.3</span> Sub-structuring</h3>
<p>The input and output mean and covariance are given by, <span class="math display">\[\begin{equation}
\mu_\mathbf{x} = \left(\begin{array}{c}
    M(\mu_{\mathbf{\vec{[Y]}}}) \\
    M(\mu_{[\mathbf{\vec{Z}}_j]})
\end{array} \right)  \qquad     \Sigma_\mathbf{x} =  \left[\begin{array}{ll} \Sigma_\mathbf{[\vec{Y}]} &amp;    \mathbf{0} \\
\mathbf{0}&amp; \Sigma_{\vec{\mathbf{Z}}_j}
\end{array}\right] \qquad \mbox{and}\qquad  \mu_\mathbf{y} =
M\left(\mu_{\mathbf{\vec{Y}}_C}\right) \qquad \Sigma_{\mathbf{y}} = \Sigma_{\vec{\mathbf{Y}}_C}
\end{equation}\]</span> The Jacobian of the underlying function (<a href="#eq-dual" class="quarto-xref">Equation&nbsp;3</a>) is given by <span class="math display">\[\begin{equation}\label{ssJ}
        \mathbf{J} =  \left[ \begin{array}{c c}
        \mathbf{J}_{[\mathbf{Y}]} &amp; \mathbf{J}_{\mathbf{Z}_j}
    \end{array}\right]
\end{equation}\]</span> <span class="math display">\[\begin{align}
    \mathbf{J}_{[\mathbf{Y}]}= \mathcal{M}\,\Bigg(\mathbf{I} - \left[\left(\mathbf{B}^{\rm T}\left(\mathbf{B} \mathbf{Y} \mathbf{B}^{\rm T}\right)^{-1} \mathbf{B}\mathbf{Y}\right)^{\rm T}\otimes \mathbf{I} \right] &amp;+ \left[ \left(\mathbf{B}^{\rm T}\left(\mathbf{B} \mathbf{Y} \mathbf{B}^{\rm T}\right)^{-1} \mathbf{B}\mathbf{Y}\right)^{\rm T}  \otimes \mathbf{Y}\mathbf{B}^{\rm T}\left(\mathbf{B} \mathbf{Y} \mathbf{B}^{\rm T}\right)^{-1}\mathbf{B} \right] \cdots \\ &amp;-
    \left[ \mathbf{I}   \otimes \mathbf{Y}\mathbf{B}^{\rm T}\left(\mathbf{B} \mathbf{Y} \mathbf{B}^{\rm T}\right)^{-1}\mathbf{B} \right],\, \mathbf{0}\Bigg) \nonumber
\end{align}\]</span> <span class="math display">\[\begin{equation}\label{ssJ2}
    \mathbf{J}_{\mathbf{Z}_j} = \mathcal{M}\,\Bigg(\left[\left(\left(\mathbf{B}\mathbf{Y}\mathbf{B}^{\rm T} + \mathbf{\Gamma}\right)^{-1}\mathbf{B}\mathbf{Y}\right)^{\rm T} \otimes \mathbf{Y}\mathbf{B}^{\rm T} \left(\mathbf{B}\mathbf{Y}\mathbf{B}^{\rm T} + \mathbf{\Gamma}\right)^{-1}\right]\bigg[-\mathbf{\Gamma}^{\rm T}\otimes \mathbf{\Gamma}\bigg],\, \mathbf{0}\Bigg)
\end{equation}\]</span></p>
</section>
</section>
<section id="unscented-transformation" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="unscented-transformation"><span class="header-section-number">3.3</span> Unscented transformation </h2>
<p>The Unscented Transformation (UT) is a method to propagate the mean and covariance of a random variable through a non-linear function and so estimate the mean and covariance of its output. Fundamentally, it is based on the notion that .</p>
<div id="fig-sigmaPoint" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-sigmaPoint-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="sigmaPoints.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-sigmaPoint-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Example of sigma points approximation for a <span class="math inline">\(N=2\)</span> dimensional normal distribution.
</figcaption>
</figure>
</div>
<p>Rather than attempting to approximate the function <span class="math inline">\(G(\square)\)</span>, as is done by the LPU (and its higher order extensions), <span class="math inline">\(G(\square)\)</span> is retained in it complete form, and instead the input distribution <span class="math inline">\(\mathbf{x}\sim\mathcal{N}\left(\mu_\mathbf{x},\Sigma_\mathbf{x}\right)\)</span> is approximated by a series of so-called (as illustrated in <a href="#fig-sigmaPoint" class="quarto-xref">Figure&nbsp;1</a>). In contrast to a MC propagation, these sigma points are not chosen at random, they are chosen deterministically such that their mean and covariance are exactly equal to that of their underlying distribution (<span class="math inline">\(\mu_\mathbf{x}\)</span> and <span class="math inline">\(\Sigma_\mathbf{x}\)</span>). In this sense they approximate the probability distribution function of <span class="math inline">\(\mathbf{x}\)</span>.</p>
<p>To exactly capture the mean and covariance of an <span class="math inline">\(N\)</span> dimensional distribution, at least <span class="math inline">\(N+1\)</span> sigma points are required. This minimum set of sigma points is distributed asymmetrically, and and for high dimensional problems must be determined matrix inverse methods. To avoid this, it is often convenient to choose <span class="math inline">\(2N\)</span> symmetrically distributed sigma points, or <span class="math inline">\(2N+1\)</span> including the mean value (as illustrated in <a href="#fig-sigmaPoint" class="quarto-xref">Figure&nbsp;1</a>).</p>
<p>To estimate the mean and covariance of the output, each sigma point is evaluated by the function <span class="math inline">\(G(\square)\)</span>. From the resulting outputs we are able to estimate <span class="math inline">\(\mu_\mathbf{y}\)</span> and <span class="math inline">\(\Sigma_{\mathbf{y}}\)</span>. Remarkably, it has been shown that the UT estimates are accurate to second order, in contrast to LPU estimates which are only first order accurate. Furthermore, this improved accuracy is achieved at no additional computational cost compared to LPU.</p>
<p>A further advantage of the UT approach is that utilities full functional evaluations, and so does not require any Jacobians, meaning it can be applied as a black-box tool for any function <span class="math inline">\(G(\square)\)</span>. An immediate application in the context of TPA is to regularised solutions of inverse problems for which Jacobians are not yet available analytically.</p>
<p>Various implementations of the Unscented Transform have been proposed in the literature, mostly differing in terms of how the sigma points are selected and what weightings are applied. In the present paper we adopt the standard symmetric form including the mean value (<span class="math inline">\(2N+1\)</span> sigma points). Details of the underlying theory of this form can be found in .</p>
<p>The Unscented Transform procedure adopted in this paper is as follows:</p>
<ol type="1">
<li><p>The <span class="math inline">\(2N+1\)</span> sigma points <span class="math inline">\(\boldsymbol{\chi}_i\)</span> and their corresponding weights <span class="math inline">\(\omega_i\)</span> are obtained using the following, <span class="math display">\[\begin{eqnarray}
     &amp;\boldsymbol{\chi}_0 = \mu_\mathbf{x}  &amp;{\omega}_0 = \frac{\kappa}{N+\kappa}\\
     &amp;\boldsymbol{\chi}_i  = \mu_\mathbf{x} + \left(\sqrt{(N+\kappa)\Sigma_\mathbf{x}}\right)_i  &amp;{\omega}_i = \frac{1}{2(N+\kappa)}\\
     &amp;\boldsymbol{\chi}_{i+N} = \mu_\mathbf{x} - \left(\sqrt{(N+\kappa)\Sigma_\mathbf{x}} \right)_i &amp;{\omega}_{i+N} = \frac{1}{2(N+\kappa)}  
\end{eqnarray}\]</span> where <span class="math inline">\(\boldsymbol{\chi}_n\in\mathbb{R}^{N}\)</span> is the <span class="math inline">\(n\)</span>th sigma point vector, <span class="math inline">\(\kappa\)</span> is a scaling parameter that controls the influence of the mean sigma point <span class="math inline">\(\boldsymbol{\chi}_0\)</span>, <span class="math inline">\(\mu_\mathbf{x}\)</span> and <span class="math inline">\(\Sigma_{\mathbf{x}}\)</span> are the mean and covariance of the input vector <span class="math inline">\(\mathbf{x}\)</span>, and <span class="math inline">\(\left(\sqrt{(N+\kappa)\Sigma_\mathbf{x}}\right)_i\)</span> denotes the <span class="math inline">\(i\)</span>th column of the matrix square-root of <span class="math inline">\(\sqrt{(N+\kappa)\Sigma_\mathbf{x}}\)</span>. The matrix square-root can be computed in several ways, though the preferred approach is to use a Cholesky decomposition (<span class="math inline">\(\mathbf{A}=\mathbf{L}\mathbf{L}^{\rm T} \rightarrow \sqrt{\mathbf{A}} = \mathbf{L}\)</span>). In the present paper we consider <span class="math inline">\(\kappa = 3-N\)</span>, which has been shown to be optimal for normally distributed input .</p>
<p>Note that whilst the sigma points described above satisfy the mean and covariance requirements, <span class="math display">\[\begin{equation}
     \mu_\mathbf{x} = \sum_{i=0}^{2N} {\omega}_i     \boldsymbol{\chi}_i  \qquad \qquad
     \Sigma_\mathbf{x} =  \sum_{i=0}^{2N}  {\omega}_i  \left(    \boldsymbol{\chi}_i  -  \mu_\mathbf{x} \right) \left(   \boldsymbol{\chi}_i  -\mu_\mathbf{x} \right)^{\rm T}
\end{equation}\]</span> they are not unique. Other sigma point selections are possible, a detailed review of which can be found in .</p></li>
<li><p>Each sigma point is used to evaluate the function <span class="math inline">\(G(\square)\)</span>, resulting in the output samples <span class="math inline">\(\mathbf{y}_i\)</span>, <span class="math display">\[\begin{equation}
     \mathbf{y}_i = G(\boldsymbol{\chi}_i)
\end{equation}\]</span></p></li>
<li><p>The mean and covariance of the output <span class="math inline">\(\mathbf{y}\)</span> are then estimated using the weighted formulae,<br>
<span class="math display">\[\begin{equation}
     {\mu_\mathbf{y}} = \sum_{i=0}^{2N} {\omega}_i   \mathbf{y}_i  \qquad \qquad
     \Sigma_\mathbf{y} =  \sum_{i=0}^{2N}  {\omega}_i  \left(    \mathbf{y}_i  - {\mu_\mathbf{y}}  \right) \left(    \mathbf{y}_i  - {\mu_\mathbf{y}} \right)^{\rm T}
\end{equation}\]</span></p></li>
</ol>
<p>Whilst the UT procedure bares some resemblence to the MC approach described in <a href="#sec-MC" class="quarto-xref">Section&nbsp;3.1</a> - both are based on the repeated evaluation of the underlying function - they are fundementally different. The UT function evaluations are chosen <em>determinisitcally</em>, whilst the MC evaluations are done at random. Furthermore, the UT estimates are obtained by <em>weighted</em> mean and covariance calculations, whilst MC esimtates utlise the standard formulae.</p>
<p>As a blackbox tool, the UT can readily be applied to a variety of TPA problems, as illustrated in the numerical and experimental examples below. We term this union of the UT and TPA, Unscented TPA (U-TPA).</p>
</section>
</section>
<section id="sec-numSim" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Numerical examples</h1>
<p>In this section we present two simple numerical examples to illustrate the Unscented-TPA concept. Comparisons are given against both Monte-Carlo simulations and linearised (LPU) propagation. In both examples, the mass-spring system illustrated in <a href="#fig-numSim" class="quarto-xref">Figure&nbsp;2</a> is used. The system is comprised of two components (a ‘source’ in green and a ‘receiver’ in blue) and are connected by series of joint impedance <span class="math inline">\(Z_{j_n}\)</span>. The mass, stiffness and damping values for the system considered are given in <a href="#tbl-numSimVals" class="quarto-xref">Table&nbsp;1</a>.</p>
<div id="fig-numSim" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-numSim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numSimDiag.png" class="img-fluid figure-img" style="width:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-numSim-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Numerical example.
</figcaption>
</figure>
</div>
<section id="sub-structuring---uncertain-joint-dynamics" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="sub-structuring---uncertain-joint-dynamics"><span class="header-section-number">4.1</span> Sub-structuring - uncertain joint dynamics</h2>
<p>In this first example we consider the problem of uncertain joint dynamics. The stiffness <span class="math inline">\(k\)</span> and damping <span class="math inline">\(c\)</span> of each connection (<span class="math inline">\(Z_j = k_j+ic_j\)</span>) are treated as random variables; collectively these are modelled as a multidimensional (<span class="math inline">\(N=6\)</span>) normal distribution with mean and covariance. The aim is to estimate the resulting uncertainty in the coupled FRF based on the sub-structuring formulation presented in <a href="#sec-dual" class="quarto-xref">Section&nbsp;2.3</a>. The FRFs of the components are assumed to be known, and so the only uncertainty comes from the joint dynamics.</p>
<div id="tbl-numSimVals" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-numSimVals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Mass, stiffness and damping values used in numerical example. Structural damping is also included with a constant loss-factor <span class="math inline">\(\eta=?\)</span>
</figcaption>
<div aria-describedby="tbl-numSimVals-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(m_n\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><span class="math inline">\(k_n\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(c_n\)</span></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
<p>The input mean vector is given by, <span class="math display">\[\begin{equation}
    \mu_\mathbf{x} = \left(\begin{array}{cccccc}
        \mu_{k_1} &amp;     \mu_{c_1} &amp;     \mu_{k_2} &amp;     \mu_{c_2} &amp;     \mu_{k_3} &amp;     \mu_{c_3}
    \end{array}\right)^{\rm T} =  \left(\begin{array}{cccccc}
        1e3 &amp; 1 &amp; 2e3 &amp; 2 &amp; 3e3 &amp; 3
        \end{array}\right)^{\rm T}
\end{equation}\]</span> and the covariance matrix <span class="math inline">\(\Sigma_\mathbf{x}\)</span> is expressed in terms of a correlation matrix and the stiffness/damping standard deviations as so, <span class="math display">\[\begin{equation}\label{paramCov}
    \sigma_\mathbf{x} = \left[\begin{array}{cccccc}
        \sigma_{k_1} &amp; &amp; &amp; &amp; &amp;\\
        &amp;\sigma_{c_1} &amp; &amp; &amp; &amp; \\
        &amp; &amp; \sigma_{k_2} &amp; &amp; &amp; \\
        &amp; &amp; &amp; \sigma_{c_2} &amp; &amp; \\
        &amp; &amp; &amp; &amp; \sigma_{k_3} &amp; \\
        &amp; &amp; &amp; &amp; &amp; \sigma_{c_3}
        \end{array}\right]  \left[\begin{array}{cccccc}
        1&amp; 0.5&amp; &amp; &amp; &amp;\\
        0.5&amp;1&amp; &amp; &amp; &amp; \\
        &amp; &amp; 1 &amp;-0.9 &amp; &amp; \\
        &amp; &amp; -0.9&amp; 1 &amp; &amp; \\
        &amp; &amp; &amp; &amp; 1 &amp; 0 \\
        &amp; &amp; &amp; &amp; 0 &amp; 1
        \end{array}\right] \left[\begin{array}{cccccc}
        \sigma_{k_1} &amp; &amp; &amp; &amp; &amp;\\
        &amp;\sigma_{c_1} &amp; &amp; &amp; &amp; \\
        &amp; &amp; \sigma_{k_2} &amp; &amp; &amp; \\
        &amp; &amp; &amp; \sigma_{c_2} &amp; &amp; \\
        &amp; &amp; &amp; &amp; \sigma_{k_3} &amp; \\
        &amp; &amp; &amp; &amp; &amp; \sigma_{c_3}
        \end{array}\right].
\end{equation}\]</span> In the examples presented, we set <span class="math inline">\(\sigma_{k_1}=\sigma_{k_2}=\sigma_{k_3}= \sigma_{k}\)</span> and <span class="math inline">\(\sigma_{c_1}=\sigma_{c_2}=\sigma_{c_3}=\sigma_{c}\)</span> and consider two scenarios chosen to illustrate: a) low level uncertainty where LPU and UT are in agreement with MC (<span class="math inline">\(\sigma_k = 2\times 10^1\)</span>, <span class="math inline">\(\sigma_c = 2\times 10^{-1}\)</span>) and b) mid range uncertainty where UT out performs the LPU (<span class="math inline">\(\sigma_k = 2\times 10^2\)</span>, <span class="math inline">\(\sigma_c = 2\times 10^0\)</span>). It is noted that for the mid level uncertainty, it is possible that some MC samples yield negative stiffness of damping. Though non-physical, this is not considered an issue here, as we are simply assessing the analytical validity of the LPU and UT compared to MC.</p>
<div id="2d76fbd6" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>plt.plot([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Unscented-TPA_files/figure-html/cell-2-output-1.png" width="571" height="411" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="force-identification" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="force-identification"><span class="header-section-number">4.2</span> Force identification</h2>
</section>
</section>
<section id="sec-expEx" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Experimental example</h1>
</section>
<section id="sec-conc" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Conclusions</h1>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{meggitt2025,
  author = {Meggitt, Joshua and Forrier, Bart and Bianciardi, Fabio},
  title = {Unscented-TPA: A General Uncertainty Framework for {Transfer}
    {Path} {Analysis}},
  volume = {1},
  number = {1},
  date = {2025-01-01},
  doi = {10.5555/12345678},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-meggitt2025" class="csl-entry quarto-appendix-citeas" role="listitem">
Meggitt, Joshua, Bart Forrier, and Fabio Bianciardi. 2025.
<span>“Unscented-TPA: A General Uncertainty Framework for Transfer Path
Analysis.”</span> Journal of TBC. January 1, 2025. <a href="https://doi.org/10.5555/12345678">https://doi.org/10.5555/12345678</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../../papers/papers.html" class="pagination-link" aria-label="List of papers">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">List of papers</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->




</body></html>